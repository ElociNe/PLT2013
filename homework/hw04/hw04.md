## Problem 1

Recursion can be implemented without resort to mutable environments in the meta
language.  Several approaches are listed below.  Choose one of them and
reimplement the [RCFAE](../../lecturenotes/08-rcfae.scala) language.  If you
are really enthusiatic and energitic, try as many of them as possible.

- The essential idea is to delay the creation of the closure.  There are
  several ways to achieve it, depending on the representation of the
  environment and the evaluation strategy of the meta-language.

    - If the environment is represented as a meta-function.  Then the recursive
      environement is given by a recursive meta-function.

    - If the environment is represented as a stack of bindings in the
      meta-language and the meta-language uses lazy evaluation, then the
      recursive environment is given by a recursive equation.  See [tying the
      knot](http://www.haskell.org/haskellwiki/Tying_the_Knot)

    - If the environment is represented as a stack of bindings in the
      meta-language but the meta-language uses eager evaluation, add the
      binding of the lambda-abstraction (instead of a closure) to the name into
      the environment.  Later when the name is looked up, create a closure out
      of the returned lambda-abstraction and the environment from the position
      where the binding is found upwards.  For this to work, the position for
      this binding in the environment must be somehow marked or detected.
      There are two ways to do it:

        - When extending the environment with the binding, use a different tag
          than the tag for normal bindings.  See the paper [Definitional
          Interpreters](http://cs.au.dk/~hosc/local/HOSC-11-4-pp363-397.pdf).

        - Check whether the returned value of a lookup is a lambda-abstraction.

- If the environment is represented as a stack of scopes, each being a
  collection of bindings.  Create a closure at the definition site but save the
  depth of the current environment instead of the environment itself.  Continue
  by adding the binding of the name with this closure to the current
  environment.  Later when the name is looked up, obtain the static environment
  with updated bindings by truncating the current environment by the depth
  saved in the returned closure.

## Problem 2

### Review Question

We have seen that [BCFAE](../../lecturenotes/09-bcfae.scala) adds support for
a simple kind of mutable data structure to
[FAE](../../lecturenates/05-fae.scala).  But we have not seen mutable
variables.  In fact, mutable variables can be simulated in BCFAE.  How do you
simulate them?  A mutable variable can be initialized, assigned and referenced,
how do you simulate these operations using the operations on boxes?

### Programming Task

A language can support mutable variables directly.  In such a language, the
environment maps all variable names to addresses, whereas the store maps
addresses to values.  When a variable appears in an expression position, the
address bound to the variable name is looked up in the environment, then the
value located in the address is fetched from the store.  However, when
a variable (name) appears on the left of an assignment (that is, as the first
argument to `Ass`), only the address bound to it is looked up in the
environment, then the value of the expression (the second argument to `Ass`) is
saved into the store at this address, replacing old values there.  When
a function is applied, a new address is first obtained (by calling
`addr.next`), then a binding of this address to the parameter name is entered
into the static environment, and a binding of the argument to this address is
entered into the store.  Start with the following declarations, implement such
a language with mutable variables.

```scala
abstract class Exp

case class Var(name : Symbol) extends Exp
case class Fun(pname : Symbol, body : Exp) extends Exp
case class App(fexp : Exp, aexp : Exp) extends Exp
case class Num(num : Int) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp
case class If0(cond : Exp, texp : Exp, fexp : Exp) extends Exp
case class Ass(vname : Symbol, exp : Exp) extends Exp  // assignment
case class Seq(exp1 : Exp, exp2 : Exp) extends Exp  // sequence

def Wth(vname : Symbol, vdef : Exp, body : Exp) : Exp =
  App(Fun(vname, body), vdef)

abstract class Val

type Addr = Int  // address
type Env = Map[Symbol, Addr]

case class NumV(num : Int) extends Val
case class CloV(pname : Symbol, body : Exp, env : Env) extends Val  // closure

object addr {  // address provider
  private var addr : Addr = -1
  def next : Addr = { addr += 1; addr }
}

type Sto = Map[Int, Val]

def eval(exp : Exp, env : Env, sto : Sto) : (Val, Sto) = ...
```

