# Homework 3

## Problem 1

We have seen [FAE](../../lecturenotes/05-fae.scala) has two features:

1. Functions are first-class.

2. It supports anonymous functions.

Anonymous functions are convenient to have but turns out to be _not_ necessary.
A language can support always named first-class functions.  To turn FAE into
such a language, we replace the constructor `Fun` with `Defun` that always
associates a name to a function.  All other things remain unchanged.  Take the
following declarations as a starting point, implement an environment-based
evaluator for this language.

```
abstract class Exp

case class Num(n : Int) extends Exp
case class Id(name : Symbol) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp

case class Defun(f : Symbol, param : Symbol, body : Exp) extends Exp
case class App (funExp : Exp, argExp : Exp) extends Exp

abstract class Value

case class NumV(n : Int) extends Value
case class ClosureV(param : Symbol, body : Exp, env : Env) extends Value

type Env = Map[Symbol, Value]

def eval(exp : Exp, env : Env) : Value = ...
```

Notice that in this language, the `With` construct is missing.  Give a
_definition_ of it (in Scala) in terms of other constructs in the language,
similar to what is done in FAE.

What can you conclude from this exercise?

## Problem 2

Port/translate to Scala the ML implementation of one _normalization_ strategy
(that is, strategy that aims to reduce a lamdba-term to its _normal form_) for
the lambda-calculus presented in the paper [Demonstrating Lambda Calculus
Reduction](http://www.itu.dk/~sestoft/papers/sestoft-lamreduce.pdf).  In the
paper, every strategy given in the first grid of the table in Figure 2 is a
normalization strategy.  Sections 6 (where the term _normal form_ is defined),
7 and 8 of paper are relevant.

## Problem 3 (Optional)

We have seen [F1WAE](../../lecturenotes/04-f1wae.scala) has two features:

1. Functions are second-class.

2. Function names and variable names live in difference name spaces.

It turns out that we can turn [F1WAE](../../lecturenotes/04-f1wae.scala) to
support first-class functions while still keeping function names and variable
names in different name spaces.  The declarations below illustrates how to do
it.  The trick is to add another constructor `Fun` that wraps a function name
into an `Exp`.  Then we introduce a new construct `FCall` that allows any `Exp`
in the head position (the first argument of `FCall`) of a function call.  The
difference between `Call` and `FCall` when evaluated is that you can directly
call the function bound to `f` for the former, while for the latter you need do
something to `funExp` first.  We also introduce another construct `Defun` that
allows users to define their own functions.  Note that evaluting `Defun` should
not return a `Closure` as value since `Closure` is not a `Value` in this
language.  Think about what you should return.  Take these declarations as a
starting point, implement an environment-based evaluator for this language.

```
abstract class Exp

case class Num(n : Int) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp
case class Mul(lhs : Exp, rhs : Exp) extends Exp
case class Id(x : Symbol) extends Exp

case class With(x : Symbol, xdef : Exp, body : Exp) extends Exp

case class Call(f : Symbol, argExp : Exp) extends Exp

case class Fun(f : Symbol) extends Exp
case class FCall(funExp : Exp, argExp : Exp) extends Exp

case class Defun(f : Symbol, param : Symbol, body : Exp) extends Exp

case class Closure(param : Symbol, body : Exp, funs : Funs, env : Env)

abstract class Value

case class NumV(n : Int) extends Value
case class FunV(f : Symbol) extends Value

type Funs = Map[Symbol, Closure]
type Env = Map[Symbol, Value]
```

What can you conclude from this exercise?

