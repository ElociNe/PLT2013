# Homework 3

## Problem 1

We have seen [FAE](../../lecturenotes/05-fae.scala) has two features:

1. Functions are first-class.

2. It supports anonymous functions.

Anonymous functions are convenient to have but turns out to be _not_ necessary.
A language can support always named first-class functions.  To turn FAE into
such a language, we replace the construct `Fun` with a `With`-like consturct
`WithFun` that first defines a function named `f` with parameter `param` and
function body `fdef`, and then evaluates the expression `body` in which the
function named `f` may be used.  All other things remain unchanged.  Take the
following declarations as a starting point, and implement an environment-based
evaluator for this language.

```
abstract class Exp

case class Num(n : Int) extends Exp
case class Id(name : Symbol) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp

case class WithFun(f : Symbol, param : Symbol, fdef : Exp, body : Exp) extends Exp
case class App(funExp : Exp, argExp : Exp) extends Exp

abstract class Value

case class NumV(n : Int) extends Value
case class ClosureV(param : Symbol, body : Exp, env : Env) extends Value

type Env = Map[Symbol, Value]

def eval(exp : Exp, env : Env) : Value = ...
```

Notice that in this language, the `With` construct is missing.  Give a
_definition_ of it (in Scala) in terms of other constructs in the language,
similar to what is done in FAE.  Remember to test your implementation.  In
particular, all examples of FAE should work with minor adaption.

What can you conclude from this exercise?

## Problem 2

Port/translate to Scala the ML implementation of one _normalization_ strategy
(that is, strategy that aims to reduce a lamdba-term to its _normal form_) for
the lambda-calculus presented in the paper [Demonstrating Lambda Calculus
Reduction](http://www.itu.dk/~sestoft/papers/sestoft-lamreduce.pdf).  In the
paper, every strategy given in the first grid of the table in Figure 2 is a
normalization strategy.  Sections 6 (where the term _normal form_ is defined),
7 and 8 of paper are relevant.

## Problem 3 (Optional)

We have seen [F1WAE](../../lecturenotes/04-f1wae.scala) has two features:

1. Functions are second-class.

2. Functions and values are in different namespaces.

It turns out that we can turn [F1WAE](../../lecturenotes/04-f1wae.scala) to
support first-class functions while still keeping functions and values in
different namespaces.  The trick is to add another construct `Fun` that wraps a
function name into an `Exp`, and correspondingly a `FunV` that wraps a function
name into a `Value`.  Then in addition to `Call`, we introduce a new construct
`FCall` that allows any `Exp` in the head position (the first argument to
`FCall`) of a function call.  The difference between `Call` and `FCall` is that
when evaluating them you can directly call the function bound to `f` for the
former, while for the latter you need first evaluate `funExp`.  Similar to the
language in Problem 1, we also introduce a `With`-like construct `WithFun` that
allows users to define a functioin and use it.  Take the following declarations
as a starting point, and implement an environment-based evaluator for this
language.

```
abstract class Exp

case class Num(n : Int) extends Exp
case class Add(lhs : Exp, rhs : Exp) extends Exp
case class Mul(lhs : Exp, rhs : Exp) extends Exp
case class Id(x : Symbol) extends Exp

case class With(x : Symbol, xdef : Exp, body : Exp) extends Exp

case class Call(f : Symbol, argExp : Exp) extends Exp

case class Fun(f : Symbol) extends Exp
case class FCall(funExp : Exp, argExp : Exp) extends Exp

case class WithFun(f : Symbol, param : Symbol, fdef : Exp, body : Exp) extends Exp

case class Closure(param : Symbol, body : Exp, funs : Funs, env : Env)

abstract class Value

case class NumV(n : Int) extends Value
case class FunV(f : Symbol) extends Value

// function namespace
type Funs = Map[Symbol, Closure]

// value namespace
type Env = Map[Symbol, Value]
```

Make sure your implementation pass at least the tests below, though you are
encouraged to put it under more tests.  _Hint:_ Study these tests before
starting your implementation.

```
// Variable names refer to their bindings in the value namespace.
val exp1 : Exp =
  WithFun('id, 'x, Id('x),
          With('id, Num(2), Id('id)))

/* Function names refer to their bindings in the function namespace.  A
   function name can be given directly to `Call` to invoke the function bound
   to that name.  Since the function name will be looked up in the function
   namespace rather than the value namespace, it can not be shadowed by the
   same variable name. */
val exp2 : Exp =
  WithFun('id, 'x, Id('x),
          With('id, Num(2), Call('id, Num(1))))

// But a function name can be shadowed by the same function name. */
val exp3 : Exp =
  WithFun('id, 'x, Id('x),
          WithFun('id, 'x, Num(2), Call('id, Num(1))))

/* When a function name is wrapped by `Fun` to become an `Exp`, it can no
   longer be invoked by `Call`.  Instead, it must be invoked by `FCall`. */
val exp4 : Exp =
  WithFun('id, 'x, Id('x),
          With('id, Num(2), FCall(Fun('id), Num(1))))

val exp5 : Exp =
  With('y, Num(1),
       WithFun('f, 'x, Add(Call('double, Id('x)), Id('y)),
               With('g, Call('twice, Fun('f)), FCall(Id('g), Num(1)))))

val emptyEnv : Env = Map()
val emptyFuns : Funs = Map()
val testFuns : Funs =
  Map('double -> Closure('x, Add(Id('x), Id('x)), emptyFuns, emptyEnv),
      'twice ->
        Closure('f, WithFun('f2, 'x, FCall(Id('f), FCall(Id('f), Id('x))),
                            Id('f2)), emptyFuns, emptyEnv))

def testEval1(exp : Exp) : Value = eval(exp, emptyFuns, emptyEnv)
def testEval2(exp : Exp) : Value = eval(exp, testFuns, emptyEnv)

assert(testEval1(exp1) == NumV(2))
assert(testEval1(exp2) == NumV(1))
assert(testEval1(exp3) == NumV(2))
assert(testEval1(exp4) == NumV(1))
assert(testEval2(exp5) == NumV(7))
```

What can you conclude from this exercise?

